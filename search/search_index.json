{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"linkedlist/","title":"Linked List","text":""},{"location":"linkedlist/#i-what-is-a-linked-list","title":"I. what is a Linked List?","text":"<p>A linked list is a collection of nodes, where each node contains the Data (the value you store) and a reference (pointer) to the next node in the list. Instead of being stored in one continuous block of memory (like arrays), nodes are scattered in memory and linked together.</p> <p>Visualized: [10 | next] \u2192 [20 | next] \u2192 [30 | next] \u2192 null</p> <p>Each [] is a node, and null is the end of an LL.</p> <p>Types of linked list:</p> <ul> <li>singly linked list</li> <li>doubly linked list</li> <li>circular linked list</li> </ul> <p>in this week, we focus only on singly linked list.</p>"},{"location":"linkedlist/#ii-why-and-when-use-linked-lists-over-arrays","title":"II. Why and when Use Linked Lists Over Arrays?","text":"<ul> <li> <p>Arrays</p> <ul> <li>\u2714 Fast random access</li> <li>\u2714 Simple structure</li> <li>\u274c Fixed size (in many languages)</li> <li>\u274c Inserting/removing elements is expensive</li> </ul> </li> <li> <p>Linked Lists</p> <ul> <li>\u2714 Dynamic size</li> <li>\u2714 Fast insertions/deletions</li> <li>\u274c No random access</li> <li>\u274c Extra memory for pointers</li> </ul> </li> </ul> <p>In short, use arrays when you need fast index access, simple iteration, and efficient storage for mostly fixed-size data, and use linked lists when you need frequent insertions or deletions and don\u2019t need random access.</p>"},{"location":"linkedlist/#iii-how-to-write-a-singly-linked-list-in-typescript","title":"III. How to write a singly linked list in Typescript.","text":"<pre><code>//define a Node.\nclass Node {\n  next: Node | null = null;\n  data: number;\n  constructor(data: number) {\n    this.data = data;\n  }\n}\n//define a linked list\nclass LinkedList {\n  head: Node | null = null;\n  //add() method adds a new value to the end of the linked list.\n  add(data: number) {\n    const node = new Node(data);\n    if (!this.head) {\n      this.head = node;\n      return;\n    }\n    let tail = this.head;\n    while (tail.next) {\n      tail = tail.next;\n    }\n    tail.next = node;\n  }\n\n  //at() method walks the list node by node until it reaches the requested index.\n  at(index: number) {\n    if (!this.head) throw new Error(\"Index out of bounds\");\n    let counter = 0;\n    let node: Node | null = this.head;\n    while (node) {\n      if (counter === index) {\n        return node;\n      }\n      counter++;\n      node = node.next;\n    }\n    throw new Error(\"Out of bounds\");\n  }\n\n  //print() method iterates through the entire list and prints each value.\n  print() {\n    if (!this.head) {\n      return;\n    }\n    let node: Node | null = this.head;\n    while (node) {\n      console.log(node.data);\n      node = node.next;\n    }\n  }\n}\n\n//Create an empty linked list\nconst ll = new LinkedList();\n</code></pre>"},{"location":"oop-principles/","title":"Oop principles","text":""},{"location":"oop-principles/#principles-of-oop","title":"Principles of OOP","text":"<p>Topics:</p> <pre><code>*Encapsulation\n*Abstraction\n*Inheritance\n*Polymorphism\n</code></pre>"},{"location":"oop-principles/#iii-polymorphism","title":"III. Polymorphism","text":""},{"location":"oop-principles/#1-what-is-polymorphism","title":"1. what is Polymorphism?","text":"<ul> <li>Polymorphism means \u201cmany forms.\u201d</li> </ul> <p>In object-oriented programming, polymorphism is the provision of one interface to entities of different data types.[^1]</p> <p>Basically, Same method name \u2192 different behavior.</p> <p>Polymorphism helps write flexible code, reduce duplication, and make code easier to extend and maintain</p>"},{"location":"oop-principles/#2-steps-to-polymorphism","title":"2. Steps to polymorphism","text":"<ol> <li>Create a contract (Interface / abstract class)</li> <li>Create Classes That Follow the Contract</li> <li>Create Objects Using the Contract Type</li> </ol>"},{"location":"typescript/","title":"TypeScript","text":"<p>Topics:</p> <pre><code>* Introduction\n* Environment Set Up\n</code></pre>"},{"location":"typescript/#i-introduction","title":"I. Introduction","text":"<p>\"TypeScript is a very useful and powerful tool we can use to optimize our code by checking for syntax errors before runtime, giving tips on how to fix bugs before they happen and more, all by adding in types to our regular JavaScript code! </p> <p>Though we can start using TypeScript right out of the box, it does recognize that every application and developer is different, and gives us some room for flexibility. </p> <p>We get access to this flexibility/customization through the ts.config file that we will keep in the root of our application, where we can change default rules, and add some rules of our own!\"<sup>1</sup></p>"},{"location":"typescript/#typescript-property","title":"Typescript property","text":"<ul> <li>TypeScript is a\u00a0static type checker\u00a0(TypeScript checks your code before you run it)</li> <li>TypeScript is a\u00a0superset of JavaScript\u00a0(this means that any JavaScript program is also a valid TypeScript program)</li> <li>TypeScript\u00a0preserves the runtime behavior of JavaScript\u00a0(TypeScript doesn\u2019t change how JavaScript works)</li> <li>TypesScript\u00a0compiles to JavaScript</li> <li>Types are gone once it compiles to JavaScript\u00a0(the browser and\u00a0Node\u00a0don\u2019t understand TypeScript)</li> <li>Using TypeScript is a\u00a0gradual adoption</li> </ul>"},{"location":"typescript/#ii-environment-set-up","title":"II. Environment Set Up","text":""},{"location":"typescript/#download","title":"Download","text":"<p>npm install -g typescript </p>"},{"location":"typescript/#tsconfigjson","title":"tsconfig.json","text":"<p>The tsconfig file is used to help us configure and compile our code</p> <p>This file is\u00a0always\u00a0kept in the project's root, and is used to identify the compiler rules the user wants to enforce, as well as specify the root files of the project. The rules the compiler enforces are customizable based on project needs.</p> <p>To get configuration file (tsconfig.json) : tsc --init</p>"},{"location":"typescript/#compiling-with-tsc","title":"Compiling with\u00a0tsc","text":"<p>With tsconfig.json set up, tsc commands are available for compiling codes. Runs \"tsc [specific file name]\".</p> <p>When we run\u00a0tsc, our program takes our\u00a0.ts\u00a0files and\u00a0compiles\u00a0them into JavaScript code, or\u00a0.js\u00a0files. This command not only creates our\u00a0.js\u00a0files in the same directory as our\u00a0.ts\u00a0files, but also is how we are able to see the errors and bugs that the transpiler has found, allowing us to fix them immediately.</p>"},{"location":"typescript/#iii-why-bother-using-typescript","title":"III. Why Bother Using Typescript?","text":"<p>Because when js was first designed it aimed to be forgiving when it comes to mistakes, When writing JavaScript we don\u2019t get a lot of information before we run our code.</p> <p>There\u2019s no way for us to know if the JavaScript code has errors until we see the result on the page and go back to our code editor to fix the mistake and rerun the code.</p> <p>TypeScript helps you catch mistakes early, before your code runs.</p>"},{"location":"typescript/#type-in-typescript","title":"Type in Typescript","text":"<p>Javascript has something called implicit coercion where js sees different types of data interact with each other but doesn't return an error, instead it assumes  what the programmer want and automatically convert a data type to match. </p> <p>Implicit often does more harm than good. To avoid said problem, typescript requires you to state the data type clearly. Typescript acts as a body guard for your code. If the incoming types don't match, they cannot enter the function.</p> <p>Specifically,  Typescript a</p>"},{"location":"typescript/#iii-running-typescript-on-browser","title":"III. Running typescript on browser","text":"<p>Typically the browser API does not understand typescript.</p> <p>Parcel lets you write modern code (TypeScript, modules, CSS, images) and automatically makes it work in the browser with almost zero setup.</p> <p>Parcel is a web bundler that takes your TypeScript (and other files), turns them into browser-ready JavaScript, and serves or builds your website for you.</p> <ol> <li> <p>Armaan Dhanji. Typescript Notes.   https://bcitcomputing.notion.site/Typescript-Notes-4a0b4c3d87ae4ebdb9e91de401660a0e#439a6c844f14468389b61f0a08d74841\u00a0\u21a9</p> </li> </ol>"}]}